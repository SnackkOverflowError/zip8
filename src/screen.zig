const std = @import("std");
const vaxis = @import("vaxis");
const CPU = @import("chip_8.zig").CpuCore;

const bufPrint = std.fmt.bufPrint;

pub const panic = vaxis.panic_handler;

const MAX_PERIOD_NS = 16666666;

// keybinds from 1-9, A-F, 0
const KEY_BINDS: [16]u8 = .{ '6', '7', '8', 'y', 'u', 'i', 'h', 'j', 'k', 'n', ',', '9', 'o', 'l', '.', 'm' };

/// Set some scope levels for the vaxis scopes
pub const std_options: std.Options = .{
    .log_scope_levels = &.{
        .{ .scope = .vaxis, .level = .warn },
        .{ .scope = .vaxis_parser, .level = .warn },
    },
};

/// Tagged union of all events our application will handle. These can be generated by Vaxis or your
/// own custom events
const Event = union(enum) {
    key_press: vaxis.Key,
    key_release: vaxis.Key,
    focus_in,
    focus_out,
    paste_start,
    paste_end,
    paste: []const u8,
    color_report: vaxis.Color.Report,
    color_scheme: vaxis.Color.Scheme,
    winsize: vaxis.Winsize,
};

pub const App = struct {
    allocator: std.mem.Allocator,
    should_quit: bool,
    tty: vaxis.Tty,
    vx: vaxis.Vaxis,
    ontime: bool,
    timer: std.time.Timer,
    pause: bool,
    step: bool,
    cpu: CPU,

    pub fn init(allocator: std.mem.Allocator, cpu: CPU) !App {
        return .{
            .allocator = allocator,
            .should_quit = false,
            .tty = try vaxis.Tty.init(),
            .vx = try vaxis.init(allocator, .{}),
            .ontime = true,
            .timer = try std.time.Timer.start(),
            .pause = false,
            .step = false,
            .cpu = cpu,
        };
    }

    pub fn deinit(self: *App) void {
        self.vx.deinit(self.allocator, self.tty.anyWriter());
        self.tty.deinit();
    }

    pub fn run(self: *App) !void {
        var loop: vaxis.Loop(Event) = .{
            .tty = &self.tty,
            .vaxis = &self.vx,
        };
        try loop.init();

        try loop.start();
        defer loop.stop();

        // takes the full terminal screen
        try self.vx.enterAltScreen(self.tty.anyWriter());

        try self.vx.queryTerminal(self.tty.anyWriter(), 1 * std.time.ns_per_s);

        while (!self.should_quit) {
            self.timer.reset();
            loop.pollEvent();
            while (loop.tryEvent()) |event| {
                try self.update(event);
            }

            if (!self.pause) {
                try self.cpu.cycle();
            } else {
                if (self.step) {
                    try self.cpu.cycle();
                    self.step = false;
                }
            }

            self.draw();
            const exec_time: u64 = self.timer.read();
            self.ontime = MAX_PERIOD_NS > exec_time;

            if (self.ontime)
                std.time.sleep(MAX_PERIOD_NS - exec_time);

            var buffered = self.tty.bufferedWriter();
            try self.vx.render(buffered.writer().any());
            try buffered.flush();
        }
    }

    pub fn update(self: *App, event: Event) !void {
        switch (event) {
            .key_press => |key| {
                if (key.matches('c', .{ .ctrl = true }))
                    self.should_quit = true;
                if (key.matches('p', .{}))
                    self.pause = true;
                if (key.matches('s', .{ .ctrl = true }))
                    self.step = true;

                // keypad
                // 1 2 3 C
                // 4 5 6 D
                // 7 8 9 E
                // A 0 B F

                self.cpu.keys = 0;
                var mask: u16 = 1;
                for (KEY_BINDS) |bind| {
                    if (key.matches(bind, .{}))
                        self.cpu.keys |= mask;
                    mask = mask << 1;
                }
            },
            .winsize => |ws| try self.vx.resize(self.allocator, self.tty.anyWriter(), ws),
            else => {},
        }
    }

    pub fn draw(self: *App) void {
        const win = self.vx.window();
        win.clear();

        var mw_height: usize = 0;
        var mw_width: usize = 0;

        var d_offset_x: usize = 0;
        var d_offset_y: usize = 0;
        var d_height: usize = 0;
        var d_width: usize = 0;

        if (win.width > 4 * win.height) {
            mw_height = win.height;
            mw_width = win.height * 4;

            d_offset_x = mw_width;
            d_height = win.height;
            d_width = win.width - mw_width;
        } else {
            mw_width = win.width;
            mw_height = win.width / 4;

            d_offset_y = mw_height;
            d_height = win.height - mw_height;
            d_width = win.width;
        }

        const mainWindow = win.child(.{
            .width = .{ .limit = mw_width },
            .height = .{ .limit = mw_height },
            .border = .{ .where = .all },
        });
        const debugWindow = win.child(.{
            .x_off = d_offset_x,
            .y_off = d_offset_y,
            .width = .{ .limit = d_width },
            .height = .{ .limit = d_height },
            .border = .{ .where = .all },
        });

        const style: vaxis.Style = .{};

        if (mw_width < 64 * 2 or mw_height < 32) {
            _ = try mainWindow.printSegment(.{ .text = "Main Window - too small to display program", .style = style }, .{});
            _ = try debugWindow.printSegment(.{ .text = "Debug Window", .style = style }, .{});
            return;
        }

        draw_chip8_screen(self.cpu.screen_buffer, mainWindow);
        self.draw_debug_screen(debugWindow);

        // NOTE this will be removed soon
    }

    fn draw_chip8_screen(screen_buffer: [32][8]u8, win: vaxis.Window) void {
        var y: usize = 0;

        while (y < screen_buffer.len) {
            const row = screen_buffer[y];
            var x: usize = 0;
            while (x < row.len) {
                draw_byte(row[x], win, y, x);
                x += 1;
            }
            y += 1;
        }
    }

    fn draw_byte(byte: u8, win: vaxis.Window, row: usize, col: usize) void {
        const filled_cell: vaxis.Cell = .{ .char = .{ .grapheme = "â–ˆ" } };
        const empty_cell: vaxis.Cell = .{ .char = .{ .grapheme = " " } };

        var i: usize = 0;
        var mask: u8 = 0b10000000;
        while (i < 8) {
            //std.debug.print("looping through byte: {d}, {b}", .{ i, mask });
            if (byte & mask == mask) {
                win.writeCell((col * 16) + (i * 2), row, filled_cell);
                win.writeCell((col * 16) + (i * 2) + 1, row, filled_cell);
            } else {
                win.writeCell((col * 16) + (i * 2), row, empty_cell);
                win.writeCell((col * 16) + (i * 2) + 1, row, empty_cell);
            }

            mask = mask >> 1;
            i += 1;
        }
    }

    fn draw_debug_screen(self: *App, win: vaxis.Window) void {
        var msg = [_]u8{0} ** 128;
        _ = try win.printSegment(.{ .text = "Debug Window" }, .{});

        _ = try bufPrint(&msg, "Pause: {s}", .{"test"});
        _ = try win.printSegment(.{ .text = msg }, .{ .row_offset = 1 });

        _ = try bufPrint(&msg, "raw instr: {any}", .{self.cpu.curr_instr_raw});
        _ = try win.printSegment(.{ .text = msg }, .{ .row_offset = 0, .col_offset = 50 });

        _ = try bufPrint(&msg, "instr: {any}", .{self.cpu.instr_desc});
        _ = try win.printSegment(.{ .text = msg }, .{ .row_offset = 1, .col_offset = 50 });
    }
};
